rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isCpfUnchanged() {
      // If cpf is not in the incoming data, it's not being changed.
      if (!('cpf' in request.resource.data)) {
        return true;
      }
      // If it is in the incoming data, check if it's the same as the existing one.
      // If the existing one doesn't exist, this will be false, which is correct (it's a change).
      return 'cpf' in resource.data && request.resource.data.cpf == resource.data.cpf;
    }

    function isNewCpfUnique(newCpf) {
      // Checks that a document for the new CPF doesn't already exist.
      return !exists(/databases/$(database)/documents/cpfs/$(newCpf));
    }

    // Rules for User Profiles
    match /users/{userId} {
      allow read, delete: if isOwner(userId);
      allow create: if isSignedIn() && request.resource.data.uid == userId;
      // An update is allowed if the user is the owner, AND
      // either the CPF is not being changed, OR the new CPF is unique.
      allow update: if isOwner(userId) && (isCpfUnchanged() || isNewCpfUnique(request.resource.data.cpf));
      allow list: if false; // Prevent listing all users for privacy
    }

    // Rules for CPFs (to enforce uniqueness)
    match /cpfs/{cpf} {
      allow get: if isSignedIn();
      allow list: if false; // Do not allow listing all CPFs.
      // Allow creation only if the document doesn't exist (implicit in create)
      // and the creator is the one associated with the CPF being written in the user profile document as part of a batch write.
      allow create: if isOwner(get(/databases/$(database)/documents/users/$(request.resource.data.userId)).data.uid);
      allow delete: if isOwner(resource.data.userId);
      allow update: if false; // Updates are not allowed. Must delete and create.
    }

    // Rules for Tents and their subcollections
    match /tents/{tentId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update, delete: if isOwner(resource.data.ownerId);
      
      function isTentOwner() {
        return get(/databases/$(database)/documents/tents/$(tentId)).data.ownerId == request.auth.uid;
      }

      match /menuItems/{menuItemId} {
        allow read: if true;
        allow write: if isSignedIn() && isTentOwner();
      }
      
      match /rentalItems/{rentalItemId} {
        allow read: if true;
        allow write: if isSignedIn() && isTentOwner();
      }

      match /reviews/{reviewId} {
        allow read: if true;
        allow create: if isSignedIn() &&
                         request.resource.data.userId == request.auth.uid &&
                         get(/databases/$(database)/documents/reservations/$(request.resource.data.reservationId)).data.userId == request.auth.uid &&
                         get(/databases/$(database)/documents/reservations/$(request.resource.data.reservationId)).data.tentId == tentId &&
                         get(/databases/$(database)/documents/reservations/$(request.resource.data.reservationId)).data.status == 'completed' &&
                         get(/databases/$(database)/documents/reservations/$(request.resource.data.reservationId)).data.reviewed != true;
        allow update, delete: if false;
      }
    }

    // Rules for Reservations
    match /reservations/{reservationId} {
      allow get, update: if isSignedIn() && request.auth.uid in resource.data.participantIds;
      allow create: if isSignedIn() && request.auth.uid in request.resource.data.participantIds;
      // For list operations (queries), we don't use a broad `allow list`.
      // Instead, Firestore implicitly ensures that any query only returns documents
      // that the user would be allowed to `get`. This forces client-side queries
      // to be secure, e.g., using `where('participantIds', 'array-contains', currentUser.uid)`.
      allow delete: if false; // Prevent accidental deletion.
    }
    
    // Rules for Chats and Messages
    match /chats/{chatId} {
      allow get, update: if isSignedIn() && request.auth.uid in resource.data.participantIds;
      allow create: if isSignedIn() && request.auth.uid in request.resource.data.participantIds;
      // For list operations (queries), we don't use a broad `allow list`.
      // Instead, Firestore implicitly ensures that any query only returns documents
      // that the user would be allowed to `get`. This forces client-side queries
      // to be secure, e.g., using `where('participantIds', 'array-contains', currentUser.uid)`.
      allow delete: if false; // Deleting chats is not allowed.

      match /messages/{messageId} {
        // Participants of the parent chat can read and create messages.
        allow read, create: if isSignedIn() && request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participantIds;
        // Messages are immutable.
        allow update, delete: if false;
      }
    }
  }
}
